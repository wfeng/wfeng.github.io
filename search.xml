<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[MongoDB集群-分片配置]]></title>
      <url>%2F2017%2F06%2F14%2Fmongodb-docment%2F</url>
      <content type="text"><![CDATA[工作需要，技术研究mongodb的集群和分片。记录下来以免以后忘记了！ 1、配置单机mongodb mongodb 3.4下载 例子： 配置文件: one-mongo.yml 参考文档 12345678910111213141516171819202122systemLog: verbosity: 0 #日志文件输出的级别，越大级别越低,共0-5级，默认0 destination: file #可选file | syslog ,指定文件日志或者系统日志, file模式需要设置systemLog.path path: /Users/wfeng/one-mongo/log/mongdb.log #日志文件路径 timeStampFormat: ctime #日志的时间格式,可选项 ctime | iso8601-utc | iso8601-local 默认iso8601-local 推荐使用ctimeprocessManagement: fork: true # 启动守护进程在后台运行，默认为false pidFilePath: /Users/wfeng/one-mongo/ #pid的路径net: port: 27000 # 监听端口 bindIp: 127.0.0.1 # 多个ip使用,分隔 maxIncomingConnections: 65536 # mongodb实例接受的最多连接数 默认值：65536 wireObjectCheck: false # 检查文档的有效性。会稍微影响性能security: authorization: disabled # disabled或者enabled，仅对mongod有效；表示是否开启用户访问控制（Access Control） javascriptEnabled: false # 默认为true，仅对mongod有效；表示是否可用server端的javascript功能，为了安全起见，可以关闭javascriptstorage: dbPath: /Users/wfeng/one-mongo/data/ # 数据存储路径 indexBuildRetry: true # 当构建索引时mongod意外关闭，那么再次启动是否重新构建索引 journal: enabled: true # 是否开启journal日志持久存储,64位系统默认为true，32位默认为false commitIntervalMs: 30 # mongod进程提交journal日志的时间间隔，即fsync的间隔仅对mongod有效，单位：毫秒 默认100 or 30，该值可设置1-500ms之间 启动方式 1mongod --config ~/one-mongo/conf/one-mongo.yml 登陆 1mongo --port 27000 增加超级管理员 12345678910111213use admindb.createUser( &#123; user: &quot;root&quot;, pwd: &quot;123&quot;, roles: [ &#123; role: &quot;root&quot;, db: &quot;admin&quot; &#125; ] &#125;) 数据库操作 参考文档 2、配置复制集mongodb+分片集群2.1、 概念介绍参考文档 2.1.1、复制集 概念:复制集是一组具有相同数据的mongod实例，包含主节点以及从节点。集群中任何时候只有一个主节点，主节点将数据变更操作写到oplog（封顶表）中，从节点读取oplog，并将oplog中的操作应用的本地数据，从而实现数据同步。 特性 异步复制:从节点并不是实时复制主节点中的数据 自动容灾主节点宕机，主动发起选举 读操作从从节点上读到的数据可能并不是最新的 复制集成员 主节点primary：可以执行读写操作，所有节点均可以执行读操作。默认情况下，读请求只会发送给主节点，可以通过read preference设置。主节点的优先级priority至少为1。 从节点secondary：只可以执行读操作。从节点通过与主节点同步，实现备份数据的功能，复制集至少有一个从节点。通过配置复制集的配置文件可以设置从节点是否参与选举（vote=0）以及是否可以被选举为主节点（priority=0）优先级priority为0的节点不能发起选举，不能被选举为主节点，但可以投票。 仲裁节点Arbiter：本身不存储数据，不能被选举为主节点，只能投票，仲裁节点主要用于使复制集中节点个数为奇数，从而容易达到多数派。仲裁节点只消耗极少的资源，但不要与主节点、从节点部署在同一个物理节点上。 复制集管理 12345678910use admin #切换到admin数据库#配置主节点config=&#123; _id:”myset”, members: [&#123;“_id”:0,”host”:”127.0.0.1:28001”,”priority”:1&#125;]&#125;rs.initiate(config)#配置从节点rs.add(&apos;127.0.0.1:28002&apos;) 2.1.2、分片集群 概念: 分片集群是将数据存储在多台机器上的操作，主要由查询路由mongos、分片、配置服务器组成。 查询路由:查询路由根据配置服务器上的元数据将请求分发到相应的分片上，本身不存储集群的元数据，只是缓存在内存中。 分片:分片用来存储数据块。数据集根据分片键将集合分割为数据块，存储在不同的分片上。在生产环境下，通常一个分片由一个复制集组成。 配置服务器:配置服务器存储集群的元数据，包括数据与分片的映射关系，配置服务器一旦挂掉，集群将无法工作。 备份数据库 1mongodump -h dbhost -d dbname -o directory 命令格式 恢复数据库 1mongorestore -h dbhost -d dbname --directoryperdb dbdirectory dbdirectory为备份数据所在位置 2.2、例子此例子配置的 1个分片(集群1主1从)、1个配置集群(1主1从)、1个路由服务 分片复制集配置 shard1-1.yml12345678910111213141516171819202122232425262728systemLog: verbosity: 0 destination: file path: /Users/wfeng/mongo/shard1/log/shard1-1.log logAppend: true timeStampFormat: ctimestorage: dbPath: /Users/wfeng/mongo/shard1/data1-1/ indexBuildRetry: true journal: enabled: true commitIntervalMs: 30net: bindIp: 0.0.0.0 port: 27010 maxIncomingConnections: 65536sharding: clusterRole: shardsvr # 在sharding集群中，此mongod实例的角色 configsvr/shardsvrreplication: replSetName: shard1ReplSetprocessManagement: fork: true pidFilePath: /Users/wfeng/mongo/#security:# clusterAuthMode: keyFile# keyFile: /Users/wfeng/mongo/conf.d/mongodb-keyfile# authorization: enabled# javascriptEnabled: false shard1-2.yml12345678910111213141516171819202122232425262728systemLog: verbosity: 0 destination: file path: /Users/wfeng/mongo/shard1/log/shard1-2.log logAppend: true timeStampFormat: ctimestorage: dbPath: /Users/wfeng/mongo/shard1/data1-2/ indexBuildRetry: true journal: enabled: true commitIntervalMs: 30net: bindIp: 0.0.0.0 port: 27011 maxIncomingConnections: 65536sharding: clusterRole: shardsvr # 在sharding集群中，此mongod实例的角色 configsvr/shardsvrreplication: replSetName: shard1ReplSetprocessManagement: fork: true pidFilePath: /Users/wfeng/mongo/#security:# clusterAuthMode: keyFile# keyFile: /Users/wfeng/mongo/conf.d/mongodb-keyfile# authorization: enabled# javascriptEnabled: false 配置集群 config1-1.yml 12345678910111213141516171819202122systemLog: verbosity: 0 destination: file path: /Users/wfeng/mongo/config/log/config1-1.log logAppend: truestorage: dbPath: /Users/wfeng/mongo/config/data1-1/net: bindIp: 127.0.0.1 port: 27100sharding: clusterRole: configsvrreplication: replSetName: configReplSetprocessManagement: fork: true pidFilePath: /Users/wfeng/mongo/#security:# clusterAuthMode: keyFile# keyFile: /Users/wfeng/mongo/conf.d/mongodb-keyfile# authorization: enabled# javascriptEnabled: false config1-2.yml 12345678910111213141516171819202122systemLog: verbosity: 0 destination: file path: /Users/wfeng/mongo/config/log/config1-2.log logAppend: truestorage: dbPath: /Users/wfeng/mongo/config/data1-2/net: bindIp: 127.0.0.1 port: 27101sharding: clusterRole: configsvrreplication: replSetName: configReplSetprocessManagement: fork: true pidFilePath: /Users/wfeng/mongo/#security:# clusterAuthMode: keyFile# keyFile: /Users/wfeng/mongo/conf.d/mongodb-keyfile# authorization: enabled# javascriptEnabled: false 路由服务 route.yml 12345678910111213141516systemLog: verbosity: 0 destination: file path: /Users/wfeng/mongo/route/log/route.log logAppend: truesharding: configDB: "configReplSet/127.0.0.1:27100"net: bindIp: 0.0.0.0 port: 40000processManagement: fork: true pidFilePath: /Users/wfeng/mongo/#security:# clusterAuthMode: keyFile# keyFile: /Users/wfeng/mongo/conf.d/mongodb-keyfile 按顺序配置启动 配置分片主从 1234567891011121314151617 ## 启动存储服务器 mongod --config ~/mongo/conf.d/shard1-1.yml mongod --config ~/mongo/conf.d/shard1-1.yml# 登陆主存储服务 mongo --port 27010use admin#设置主存储rs.initiate(&#123;_id:&quot;shard1ReplSet&quot;,configsvr:true,members:[&#123;_id:0,host:&quot;127.0.0.1:27010&quot;&#125;]&#125;)#添加从存储rs.add(&apos;127.0.0.1:27011&apos;) 配置配置服务 1234567891011121314151617# 启动配置服务器mongod --config ~/mongo/conf.d/config1-1.ymlmongod --config ~/mongo/conf.d/config1-2.yml# 登陆主配置服务mongo --port 27100use admin#设置主配置rs.initiate(&#123;_id:&quot;configReplSet&quot;,configsvr:true,members:[&#123;_id:0,host:&quot;127.0.0.1:27100&quot;&#125;]&#125;)#添加从配置rs.add(&apos;127.0.0.1:27101&apos;) 配置路由服务 1234567891011121314151617181920212223242526272829303132# 切换admin库use admin# 创建超级管理员db.createUser(&#123; user: &quot;root&quot;, pwd: &quot;123&quot;, roles: [ &#123; role: &quot;root&quot;, db: &quot;admin&quot; &#125; ]&#125;)# 添加分区sh.addShard(&quot;127.0.0.1:27010&quot;);# 设置需要使用分区的数据库sh.enableSharding(&quot;test&quot;);# 配置业务实例库use testdb.createUser(&#123; user: &quot;test&quot; , pwd: &quot;test123&quot;, roles: [ &quot;dbAdmin&quot;, &quot;db&quot;, &quot;readWriteAnyDatabase&quot; ]&#125;); 开启安全验证 123456# 生成keyFileopenssl rand -base64 755 &gt; mongodb-keyfile# 关闭服务kill -15 $pids# 开启所有配置的security# 启动所有服务 顺序 shard =&gt; config =&gt; route]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于GitHub快速安装Hexo博客]]></title>
      <url>%2F2017%2F04%2F14%2Fsetup-hexo%2F</url>
      <content type="text"><![CDATA[刚安装的基于Hexo框架的Blog，据说很牛(Zhuang)逼。顺手写个安装记录，免得下次又到处找资料。 1. GitHub准备工作1.1 注册账号首先你必须要有GitHub账号，没有的就去注册。入行了的程序猿应该都有把，所以这个就不说了。 1.2 创建博客项目仓库(repository)首页上点击New repository按钮创建项目仓库，Respository name(仓库名称)设置成：username.github.io。注意：username一定与前面的Owner保持一致，这个地址也将会是你的博客访问地址。 2. 开始安装2.1 安装Gitbrew install git 不解释，自己看,不懂的问Google。 2.2 安装Nodejs先安装nvm,设置环境变量为国内源。 brew install nvm mkdir ~/.nvm export NVM_DIR=~/.nvm . $(brew --prefix nvm)/nvm.sh #修改Nodejs源地址为淘宝npm镜像 export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node # 同时记得配置环境变量 vim ~/.zshrc 安装Node.js,本文编写时官方推荐版本为v6.10.2 #查看Node所有版本 nvm ls-remote #安装 nvm install v6.10.2 #检查安装结果 node -v 2.3 安装Hexo框架安装Hexo框架前，先修改npm源为国内源，不然安装后可能会报错[Error: Cannot find module ‘./build/Release/DTraceProviderBindings]。(这里有坑，已填) #切换源仓库为国内淘宝npm镜像 npm config set registry http://registry.npm.taobao.org/ #安装 npm install hexo-cli -g #检查安装结果 hexo -v 3 创建博客,发布通过Hexo框架初始化一个博客，并进行自定义配置。写文章，发布到GitHub网站。 3.1 创建博客项目创建出一个名为 username.github.io 的文件夹(同上面设置的一致)。 #创建项目(会在当前位置生成项目目录) hexo init username.github.io 3.2 配置博客安装主题#进入项目目录 cd username.github.io #获取主题(演示代码选择主题为NexT，效果简约好看，俺喜欢) git clone https://github.com/iissnan/hexo-theme-next themes/next 更多主题 博客基础配置配置文件位置：username.github.io/_config.yml如何配置参考官方文档 主题配置配置文件位置：username.github.io/themes/next/_config.yml例如：设置首页不显示全文查找auto_excerpt，并将enable属性值设为true auto_excerpt: enable: true length: 150 参考文档 3.3 写文章文章数据存放目录：username.github.io/source/_posts文件格式Markdown,例子：first-page.md --- title: 测试文档标题 date: 2017-04-14 tags: - tag1 - tag2 categories: - category - subcategory --- # 这是一篇测试文章 Markdown格式，程序猿的最爱。 要启用分类和标签功能要先安装 hexo new page categories hexo new page tags 并在生成目录的index.md中设置 type: &quot;categories&quot; # categories/index.md add type: &quot;tags&quot; # tags/index.md add 3.4 测试hexo s 启动测试服务后，通过https://localhost:4000进行访问。 3.5 安装自动部署发布工具npm install hexo-deployer-git --save 3.6 发布博客测试通过后，生存静态网页文件发布到我们的Github pages中。 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 3.7 基本操作完成到这里，博客就已经发布完成，记住你上面配置的地址。例如：http://wfeng.github.io 4 后续配置备注4.1 Hexo常用命令hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #在_posts下新建指定功能页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #发布hexo博客 #简写 hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 4.2 开启站内搜索功能 Local Search开启搜索功能需要先安装hexo搜索工具 hexo-generator-searchdb npm install hexo-generator-searchdb --save 然后在主题配置文件_config.yml文件中开启local_search功能 # Local search local_search: enable: true]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[新的开始，新的起点]]></title>
      <url>%2F2017%2F04%2F13%2Ffirst-page%2F</url>
      <content type="text"><![CDATA[因为种种原因，原来的blog数据丢失了，最近事情也很多，所以也不想找了。这两天算是把事情理顺了点，又想把博客挂出来，那就重新来过把，算是个新的开始。]]></content>
    </entry>

    
  
  
</search>
